# config.py
#  TuxOstat configuration program
# TuxOstat - Linux-based thermostat <http://www.jasonantman.com>
# Copyright 2008 Jason Antman. <jason@jasonantman.com>.
# Licensed under Version 3 or later of the GNU GPL.
#  Time-stamp: "2008-06-15 17:36:59 tuxostat"
#  $Id: tosSched.py,v 1.1.1.4 2008/06/19 23:14:57 jantman Exp $

import cPickle as pickle
import shutil
import time
import os.path

class tosSched:
    """
    This class handles all reading and writing of the configuration files and schedule.
    """

    SCHEDULE_FILE = '/etc/tuxostat/schedule.pkl'
    SCHEDULE = None

    # non-private variables
    days = {0: "M ", 1: "Tu", 2: "W ", 3: "Th", 4: "F ", 5: "Sa", 6: "Su"} # day names - string length 2
    HVACmodes = {0: "DEF ", 1: "COOL", 2: "HEAT", 3: "EITH", 4: "OFF "} # HVAC system mode - string length 4
    zoneModes = {0: "Mean", 1: "MED ", 2: "Wmed", 3: "OUTL", 4: "ZONE"} # how to use zones - string length 4
    tempModes = {0: "Time", 1: "Temp"} # how to handle temperature - string length 4

    def __init__(self):
        """
        Instantiate the config object, and load in the config and schedule.
        """
	self.LoadSchedule()

    def LoadSchedule(self):
	"""
	Read-in (unpickle) the schedule.
	"""
	if os.path.exists(self.SCHEDULE_FILE):
	        f2 = file(self.SCHEDULE_FILE, 'rb')
		self.SCHEDULE = pickle.load(f2)
		f2.close()
	else:
		self.SCHEDULE = {}

    def GetSchedule(self):
        """
        This returns the entire schedule, which is a list of dictionaries.
        """
        return self.SCHEDULE

    def AddTaskAtEnd(self, task):
        """
        Adds a new task to the end of the schedule.
        """
        self.SCHEDULE.append(task)

    def AddTaskBefore(self, task, beforeIndex):
        """
        This adds a new task into the schedule before the specified index. The task should be a dictionary. This function does NOT write out the schedule (pickle it), it just adds to the current data structure, so the user has a chance to review and confirm changes.
        """
        self.SCHEDULE.add(beforeIndex, task)

    def WriteSchedule(self):
        """
        Write out (pickle) the schedule. First, it moves the old file to /etc/tuxostat/schedule_{current_integer_timestamp}.pkl. Returns the filename that the old schedule was moved to.
        """
	newname = '/etc/tuxostat/schedule_'+str(int(time.time()))+'.pkl'
	shutil.move('/etc/tuxostat/schedule.pkl', newname)
        f2 = file(self.SCHEDULE_FILE, 'wb')
        pickle.dump(self.SCHEDULE, f2, False)
        f2.close()
	return newname

    def GetScheduleNumTasks(self):
	"""
	Returns the integer number of tasks in the current schedule.
	"""
	return len(self.SCHEDULE)

    def RemoveScheduleTask(self, index):
	"""
	Removes the schedule task at the specified index.
	"""
	self.SCHEDULE.pop(index)
	return True

    def ReplaceTask(self, index, task):
	"""
	Replaces the current task at index with a new task dictionary "task"
	"""
	if index < 0 or index > len(self.SCHEDULE):
	   return False
	self.SCHEDULE[index] = task
	return True

    def GetTaskByID(self, taskID):
        """
        Returns the task (dict) with the specified ID).
        """
        return self.SCHEDULE[taskID]

    def GetCurrentTaskID(self):
        """
        Returns the task ID (list index) for the current task. This ASSUMES that the whole schedule is in chronological order.
        """
        
        nowtime = time.localtime() # struct_time for NOW
        nowday = nowtime[6]
        nowhr = nowtime[3]
        nowmin = nowtime[4]
        nowmins = nowmin + (nowhr * 60)
        
        # iterate through the schedule
        count = 0
        for t in self.SCHEDULE:
            tday = t["Day"]
            tmin = int(t["Time"][t["Time"].find(":")+1:])
            thr = int(t["Time"][:t["Time"].find(":")])
            tmins = tmin + (thr * 60)
            
            if tday > nowday:
                # we just went into tomorrow
                return (count-1)
            elif tday == nowday:
                # same day of the week, look at the hours:
                if tmins > nowmins:
                    return (count-1)
            # increment count
            count = count + 1
        # if we got here, we're at the last schedule item. return that.
        return (count-1)
